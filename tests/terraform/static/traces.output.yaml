---
# Source: sumologic/templates/setup/setup-configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name:  RELEASE-NAME-sumologic-setup
  annotations:
    helm.sh/hook: pre-install,pre-upgrade
    helm.sh/hook-weight: "2"
    helm.sh/hook-delete-policy: before-hook-creation,hook-succeeded
  labels:
    app: RELEASE-NAME-sumologic
    chart: "sumologic-%CURRENT_CHART_VERSION%"
    release: "RELEASE-NAME"
    heritage: "Helm"
data:
  custom.sh: |
    #!/bin/bash
    #
    # This script copies files from /customer-scripts to /scripts/<dirname> basing on the filename
    #
    # Example file structure:
    #
    # /customer-scripts
    # ├── dir1_main.tf
    # ├── dir1_setup.sh
    # ├── dir2_list.txt
    # └── dir2_setup.sh
    #
    # Expected structure:
    #
    # /scripts
    # ├── dir1
    # │   ├── main.tf
    # │   └── setup.sh
    # └── dir2
    #     ├── list.txt
    #     └── setup.sh
    #
    # shellcheck disable=SC2010
    # extract target directory names from the file names using _ as separator
    for dir in $(ls -1 /customer-scripts | grep _ | grep -oE '^.*?_' | sed 's/_//g' | sort | uniq); do
      target="/scripts/${dir}"
      mkdir "${target}"
      # shellcheck disable=SC2010
      # Get files for given directory and take only filename part (after first _)
      for file in $(ls -1 "/customer-scripts/${dir}_"* | grep -oE '_.*' | sed 's/_//g'); do
        cp "/customer-scripts/${dir}_${file}" "${target}/${file}"
      done
      cd "${target}" && bash setup.sh
    done
  fields.tf: |
    resource "sumologic_field" "cluster" {
      count = var.create_fields ? 1 : 0
  
      field_name = "cluster"
      data_type = "String"
      state = "Enabled"
    }
  
    resource "sumologic_field" "container" {
      count = var.create_fields ? 1 : 0
  
      field_name = "container"
      data_type = "String"
      state = "Enabled"
    }
  
    resource "sumologic_field" "deployment" {
      count = var.create_fields ? 1 : 0
  
      field_name = "deployment"
      data_type = "String"
      state = "Enabled"
    }
  
    resource "sumologic_field" "host" {
      count = var.create_fields ? 1 : 0
  
      field_name = "host"
      data_type = "String"
      state = "Enabled"
    }
  
    resource "sumologic_field" "namespace" {
      count = var.create_fields ? 1 : 0
  
      field_name = "namespace"
      data_type = "String"
      state = "Enabled"
    }
  
    resource "sumologic_field" "node" {
      count = var.create_fields ? 1 : 0
  
      field_name = "node"
      data_type = "String"
      state = "Enabled"
    }
  
    resource "sumologic_field" "pod" {
      count = var.create_fields ? 1 : 0
  
      field_name = "pod"
      data_type = "String"
      state = "Enabled"
    }
  
    resource "sumologic_field" "service" {
      count = var.create_fields ? 1 : 0
  
      field_name = "service"
      data_type = "String"
      state = "Enabled"
    }
  locals.tf: |
    locals {
      default_traces_source                       = "traces"
    }
  main.tf: |
    terraform {
      required_providers {
        sumologic  = "~> 2.3.0"
        kubernetes = "~> 1.11.3"
      }
    }
  providers.tf: |-
    provider "sumologic" {}
  
    provider "kubernetes" {
    
        cluster_ca_certificate    = file("/var/run/secrets/kubernetes.io/serviceaccount/ca.crt")
        host                      = "https://kubernetes.default.svc"
        load_config_file          = "false"
        token                     = file("/var/run/secrets/kubernetes.io/serviceaccount/token")
    }
  resources.tf: |
    resource "sumologic_collector" "collector" {
        name  = var.collector_name
        fields  = {
          cluster = var.cluster_name
        }
    }
    
    resource "sumologic_http_source" "default_traces_source" {
        name         = local.default_traces_source
        collector_id = sumologic_collector.collector.id
        content_type = "Zipkin"
    }
  
    resource "kubernetes_secret" "sumologic_collection_secret" {
      metadata {
        name = "sumologic"
        namespace = var.namespace_name
      }
  
      data = {
        endpoint-traces                           = sumologic_http_source.default_traces_source.url
      }
  
      type = "Opaque"
    }
  setup.sh: |
    #!/bin/bash
  
    # Fix URL to remove "v1" or "v1/"
    export SUMOLOGIC_BASE_URL=${SUMOLOGIC_BASE_URL%v1*}
    # Support proxy for terraform
    export HTTP_PROXY=${HTTP_PROXY:=""}
    export HTTPS_PROXY=${HTTPS_PROXY:=""}
    export NO_PROXY=${NO_PROXY:=""}
  
    function remaining_fields() {
        local RESPONSE="$(curl -XGET -s \
            -u "${SUMOLOGIC_ACCESSID}:${SUMOLOGIC_ACCESSKEY}" \
            "${SUMOLOGIC_BASE_URL}"v1/fields/quota)"
  
        echo "${RESPONSE}" | jq '.remaining'
    }
  
    # Check if we'd have at least 10 fields remaining after 8 additional fields
    # would be created for the collection
    function should_create_fields() {
        local REMAINING=$(remaining_fields)
        if [[ $(( REMAINING - 8 )) -ge 10 ]] ; then
            echo 1
        else
            echo 0
        fi
    }
  
    cp /etc/terraform/{locals,main,providers,resources,variables,fields}.tf /terraform/
    cd /terraform
  
    COLLECTOR_NAME="kubernetes"
  
    terraform init
  
    # Sumo Logic fields
    readonly CREATE_FIELDS="$(should_create_fields)"
    if [[ "${CREATE_FIELDS}" -eq 0 ]]; then
        echo "Couldn't automatically create fields\n"
        echo "There's not enough fields which we could use for collection fields creation"
        echo "Please free some of them and rerun the setup job"
    else
        readonly FIELDS_RESPONSE="$(curl -XGET -s \
            -u "${SUMOLOGIC_ACCESSID}:${SUMOLOGIC_ACCESSKEY}" \
            "${SUMOLOGIC_BASE_URL}"v1/fields | jq '.data[]' )"
  
        declare -ra FIELDS=("cluster" "container" "deployment" "host" "namespace" "node" "pod" "service")
        for FIELD in "${FIELDS[@]}" ; do
            FIELD_ID=$( echo "${FIELDS_RESPONSE}" | jq -r "select(.fieldName == \"${FIELD}\") | .fieldId" )
            # Don't try to import non existing fields
            if [[ -z "${FIELD_ID}" ]]; then
                continue
            fi
  
            terraform import \
                -var="create_fields=${CREATE_FIELDS}" \
                sumologic_field."${FIELD}" "${FIELD_ID}"
        done
    fi
  
    # Sumo Logic Collector and HTTP sources
    terraform import \
        -var="create_fields=${CREATE_FIELDS}" \
        sumologic_collector.collector "$COLLECTOR_NAME"
    terraform import \
        -var="create_fields=${CREATE_FIELDS}" \
        sumologic_http_source.default_traces_source "$COLLECTOR_NAME/traces"
  
    # Kubernetes Secret
    terraform import \
        -var="create_fields=${CREATE_FIELDS}" \
        kubernetes_secret.sumologic_collection_secret sumologic/sumologic
  
    # Apply planned changes
    terraform apply -auto-approve \
        -var="create_fields=${CREATE_FIELDS}"
  
    # Cleanup env variables
    export SUMOLOGIC_BASE_URL=
    export SUMOLOGIC_ACCESSKEY=
    export SUMOLOGIC_ACCESSID=
  
    bash /etc/terraform/custom.sh
  variables.tf: |
    variable "cluster_name" {
      type  = string
      default = "kubernetes"
    }
  
    variable "collector_name" {
      type  = string
      default = "kubernetes"
    }
  
    variable "namespace_name" {
      type  = string
      default = "sumologic"
    }
  
    variable "create_fields" {
      description = "If set, terraform will attempt to create fields at Sumo Logic"
      type = bool
    }
